import { revalidatePath } from 'next/cache';
import { eq, and, or, like, desc, count, inArray, not, SQL, sql } from 'drizzle-orm';
import { ZodError } from 'zod';
import * as crypto from 'node:crypto';

import type { SessionUser } from '@/lib/auth/session';
import { getDb, getDbClient } from '@/lib/db/client';
import { partners, users, partnerMatches } from '@/lib/db/schema';
import { PartnerType } from '@/lib/constants/enums';

import {
  createPartnerSchema,
  updatePartnerSchema,
  type CreatePartnerInput,
  type UpdatePartnerInput
} from '@/lib/validators/partners';

// --- Types ---
export interface PartnerSummary {
  id: string;
  name: string;
  description: string | null;
  type: typeof PartnerType[keyof typeof PartnerType];
  contactInfo: string;
  location: string | null;
  portfolioUrl: string | null;
  verified: boolean;
  createdAt: string;
  updatedAt: string;
  user: {
    id: string;
    name: string | null;
    avatarUrl: string | null;
  };
  matchCount: number;
}

// --- Constants ---
const PARTNERS_PATH = '/partners';
const MAX_PAGE_SIZE = 50;
const DEFAULT_PAGE_SIZE = 12;

// --- Error Classes ---
export class PartnerValidationError extends Error {
  issues: string[];

  constructor(error: ZodError) {
    super('Partner input data is invalid.');
    this.name = 'PartnerValidationError';
    this.issues = error.issues.map((issue) => issue.message);
  }
}

export class PartnerProfileExistsError extends Error {
  constructor() {
    super('A partner profile already exists for this user.');
    this.name = 'PartnerProfileExistsError';
  }
}

export class PartnerOwnerNotFoundError extends Error {
  constructor() {
    super('Could not find the specified partner owner.');
    this.name = 'PartnerOwnerNotFoundError';
  }
}

export class PartnerNotFoundError extends Error {
  constructor() {
    super('The requested partner could not be found.');
    this.name = 'PartnerNotFoundError';
  }
}

export class PartnerAccessDeniedError extends Error {
  constructor() {
    super('You do not have permission to access this partner profile.');
    this.name = 'PartnerAccessDeniedError';
  }
}

// --- Utility Functions ---
const revalidatePartners = () => {
  revalidatePath(PARTNERS_PATH);
};

// --- Database Query Helpers ---
const partnerQuerySelection = {
  id: partners.id,
  name: partners.name,
  type: partners.type,
  verified: partners.verified,
  description: partners.description,
  location: partners.location,
  portfolioUrl: partners.portfolioUrl,
  contactInfo: partners.contactInfo,
  createdAt: partners.createdAt,
  updatedAt: partners.updatedAt,
  user: {
    id: users.id,
    name: users.name,
    avatarUrl: users.avatarUrl,
  },
  matchCount: sql<number>`count(${partnerMatches.id})`.mapWith(Number),
};

type PartnerQueryResult = typeof partnerQuerySelection;

const getPartnerQuery = (db: ReturnType<typeof getDb>) => {
  return db.select(partnerQuerySelection)
  .from(partners)
  .innerJoin(users, eq(partners.userId, users.id))
  .leftJoin(partnerMatches, eq(partners.id, partnerMatches.partnerId))
  .groupBy(partners.id, users.id);
};

// --- Data Transformation ---
const toPartnerSummary = (partner: PartnerQueryResult): PartnerSummary => ({
  id: partner.id,
  name: partner.name,
  type: partner.type as typeof PartnerType[keyof typeof PartnerType],
  verified: partner.verified,
  description: partner.description ?? null,
  location: partner.location ?? null,
  portfolioUrl: partner.portfolioUrl ?? null,
  contactInfo: partner.contactInfo,
  matchCount: partner.matchCount || 0,
  user: {
    id: partner.user.id,
    name: partner.user.name ?? null,
    avatarUrl: partner.user.avatarUrl ?? null,
  },
  createdAt: partner.createdAt,
  updatedAt: partner.updatedAt,
});

// --- Public API Functions ---

export interface ListPartnersParams {
  type?: typeof PartnerType[keyof typeof PartnerType];
  search?: string;
  cursor?: string;
  limit?: number;
  verified?: boolean;
  includeUnverified?: boolean;
  excludeOwnerId?: string;
}

export interface ListPartnersResult {
  items: PartnerSummary[];
  nextCursor: string | null;
}

export const listPartners = async (params: ListPartnersParams = {}): Promise<ListPartnersResult> => {
  const { type, search, cursor, excludeOwnerId } = params;
  const take = Math.max(1, Math.min(params.limit || DEFAULT_PAGE_SIZE, MAX_PAGE_SIZE));

  const conditions: SQL[] = [];

  if (type) conditions.push(eq(partners.type, type));
  if (excludeOwnerId) conditions.push(not(eq(partners.userId, excludeOwnerId)));

  if (params.includeUnverified) {
    if (typeof params.verified === 'boolean') {
      conditions.push(eq(partners.verified, params.verified));
    }
  } else {
    conditions.push(eq(partners.verified, typeof params.verified === 'boolean' ? params.verified : true));
  }

  if (search) {
    const term = `%${search.trim()}%`;
    conditions.push(or(
      like(partners.name, term),
      like(partners.description, term),
      like(partners.contactInfo, term),
      like(partners.location, term)
    ));
  }

  if (cursor) conditions.push(eq(partners.id, cursor));

  const db = await getDb();
  const query = getPartnerQuery(db);
  
  const partnersData = await (conditions.length > 0
    ? query.where(and(...conditions))
    : query)
    .orderBy(desc(partners.createdAt))
    .limit(take + 1);

  const hasNext = partnersData.length > take;
  const pageItems = hasNext ? partnersData.slice(0, -1) : partnersData;

  return {
    items: pageItems.map(toPartnerSummary),
    nextCursor: hasNext ? pageItems[pageItems.length - 1]?.id ?? null : null,
  };
};

export const getPartnerById = async (id: string): Promise<PartnerSummary> => {
  const db = await getDb();
  const results = await getPartnerQuery(db)
    .where(eq(partners.id, id));

  if (results.length === 0) {
    throw new PartnerNotFoundError();
  }

  return toPartnerSummary(results[0]);
};

export const getPartnerProfileForUser = async (userId: string): Promise<PartnerSummary> => {
  const db = await getDb();
  const results = await getPartnerQuery(db)
    .where(eq(partners.userId, userId));

  if (results.length === 0) {
    throw new PartnerNotFoundError();
  }

  return toPartnerSummary(results[0]);
};

export const createPartnerProfile = async (payload: unknown, sessionUser: SessionUser): Promise<PartnerSummary> => {
  try {
    const input = createPartnerSchema.parse(payload);
    const ownerId = sessionUser.id; // Admin can create for others, but for now, only self-registration

    const db = await getDbClient();
    const owner = await db.select().from(users).where(eq(users.id, ownerId)).limit(1).then(rows => rows[0] || null);
    if (!owner) throw new PartnerOwnerNotFoundError();

    const existingProfile = await db.select().from(partners).where(eq(partners.userId, ownerId)).limit(1).then(rows => rows[0] || null);
    if (existingProfile) throw new PartnerProfileExistsError();

    const partnerId = crypto.randomUUID();
    const newPartner = await db.transaction(async (tx) => {
      const [insertedPartner] = await tx.insert(partners).values({
        id: partnerId,
        userId: ownerId,
        name: input.name,
        type: input.type,
        contactInfo: input.contactInfo,
        description: input.description ?? null,
        location: input.location ?? null,
        portfolioUrl: input.portfolioUrl ?? null,
        verified: input.verified ?? false,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      }).returning();

      if (!insertedPartner) {
        throw new Error('Failed to create partner profile.');
      }

      // Update user role to PARTNER if not ADMIN
      if (owner.role !== 'ADMIN' && owner.role !== 'PARTNER') {
        await tx.update(users).set({ role: 'PARTNER' }).where(eq(users.id, ownerId));
      }
      return insertedPartner;
    });

    revalidatePartners();
    return getPartnerById(newPartner.id);
  } catch (error) {
    if (error instanceof ZodError) {
      throw new PartnerValidationError(error);
    }
    throw error;
  }
};

export const updatePartnerProfile = async (
  id: string,
  payload: unknown,
  sessionUser: SessionUser
): Promise<PartnerSummary> => {
  try {
    const input = updatePartnerSchema.parse(payload);
    
    const db = await getDbClient();
    const partner = await db.select().from(partners).where(eq(partners.id, id)).limit(1).then(rows => rows[0] || null);
    if (!partner) throw new PartnerNotFoundError();

    if (sessionUser.role !== 'ADMIN' && partner.userId !== sessionUser.id) {
      throw new PartnerAccessDeniedError();
    }

    // Only ADMIN can change verified status
    if (input.verified !== undefined && sessionUser.role !== 'ADMIN') {
      throw new PartnerAccessDeniedError();
    }

    const updateData: Partial<typeof partners.$inferInsert> = {};

    if (input.name !== undefined) updateData.name = input.name;
    if (input.type !== undefined) updateData.type = input.type;
    if (input.description !== undefined) updateData.description = input.description;
    if (input.contactInfo !== undefined) updateData.contactInfo = input.contactInfo;
    if (input.location !== undefined) updateData.location = input.location;
    if (input.portfolioUrl !== undefined) updateData.portfolioUrl = input.portfolioUrl;
    if (input.verified !== undefined) updateData.verified = input.verified;

    if (Object.keys(updateData).length > 0) {
      await db.update(partners).set({ ...updateData, updatedAt: new Date().toISOString() }).where(eq(partners.id, id));
    }

    revalidatePartners();
    return getPartnerById(id);
  } catch (error) {
    if (error instanceof ZodError) {
      throw new PartnerValidationError(error);
    }
    throw error;
  }
};

// --- Utility & Stats ---

export const getPartnerStats = async () => {
  const db = await getDb();
  const stats = await db.select({ // Explicitly select columns to avoid issues with `stats[0]`
      total: count(partners.id),
      verified: sql<number>`count(*) filter (where ${partners.verified} = true)`.mapWith(Number),
      pending: sql<number>`count(*) filter (where ${partners.verified} = false)`.mapWith(Number),
    })
    .from(partners);

  return stats[0] || { total: 0, verified: 0, pending: 0 };
};

export const getRecentPartners = async (limit = 5) => {
  const result = await listPartners({ limit, verified: true });
  return result.items;
};

export const getPartnersAwaitingApproval = async (limit = 5) => {
  const result = await listPartners({ limit, verified: false, includeUnverified: true });
  return result.items;
};